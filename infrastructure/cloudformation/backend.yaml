AWSTemplateFormatVersion: '2010-09-09'
Transform: AWS::Serverless-2016-10-31
Description: |
  AI Prompt Generator - Serverless Backend Stack
  Deploys Lambda, API Gateway, DynamoDB, and Secrets Manager for the API

# =========================================
# Parameters
# =========================================
Parameters:
  Environment:
    Type: String
    Default: production
    AllowedValues:
      - development
      - staging
      - production

  AIProvider:
    Type: String
    Default: claude
    AllowedValues:
      - claude
      - openai
    Description: Primary AI provider for prompt enhancement

  FrontendStackName:
    Type: String
    Default: ai-prompt-generator-frontend
    Description: Name of the frontend CloudFormation stack

  RateLimitRequests:
    Type: Number
    Default: 100
    Description: Maximum API requests per minute per IP

  LogRetentionDays:
    Type: Number
    Default: 30

# =========================================
# Globals
# =========================================
Globals:
  Function:
    Runtime: nodejs20.x
    Timeout: 30
    MemorySize: 256
    Tracing: Active
    Environment:
      Variables:
        ENVIRONMENT: !Ref Environment
        AI_PROVIDER: !Ref AIProvider
        LOG_LEVEL: !If [IsProduction, 'info', 'debug']

# =========================================
# Conditions
# =========================================
Conditions:
  IsProduction: !Equals [!Ref Environment, 'production']

# =========================================
# Resources
# =========================================
Resources:

  # -----------------------------------------
  # Secrets Manager - API Keys
  # -----------------------------------------
  APIKeysSecret:
    Type: AWS::SecretsManager::Secret
    Properties:
      Name: !Sub 'ai-prompt-generator/${Environment}/api-keys'
      Description: API keys for AI providers
      SecretString: !Sub |
        {
          "CLAUDE_API_KEY": "sk-ant-your-claude-api-key-here",
          "OPENAI_API_KEY": "sk-your-openai-api-key-here"
        }
      Tags:
        - Key: Environment
          Value: !Ref Environment
        - Key: Project
          Value: AIPromptGenerator

  # -----------------------------------------
  # DynamoDB Tables
  # -----------------------------------------
  UsageTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: !Sub 'ai-prompt-generator-usage-${Environment}'
      BillingMode: PAY_PER_REQUEST
      AttributeDefinitions:
        - AttributeName: pk
          AttributeType: S
        - AttributeName: sk
          AttributeType: S
        - AttributeName: gsi1pk
          AttributeType: S
        - AttributeName: gsi1sk
          AttributeType: S
      KeySchema:
        - AttributeName: pk
          KeyType: HASH
        - AttributeName: sk
          KeyType: RANGE
      GlobalSecondaryIndexes:
        - IndexName: gsi1
          KeySchema:
            - AttributeName: gsi1pk
              KeyType: HASH
            - AttributeName: gsi1sk
              KeyType: RANGE
          Projection:
            ProjectionType: ALL
      TimeToLiveSpecification:
        AttributeName: ttl
        Enabled: true
      PointInTimeRecoverySpecification:
        PointInTimeRecoveryEnabled: !If [IsProduction, true, false]
      Tags:
        - Key: Environment
          Value: !Ref Environment
        - Key: Project
          Value: AIPromptGenerator

  RateLimitTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: !Sub 'ai-prompt-generator-ratelimit-${Environment}'
      BillingMode: PAY_PER_REQUEST
      AttributeDefinitions:
        - AttributeName: ip
          AttributeType: S
      KeySchema:
        - AttributeName: ip
          KeyType: HASH
      TimeToLiveSpecification:
        AttributeName: ttl
        Enabled: true
      Tags:
        - Key: Environment
          Value: !Ref Environment
        - Key: Project
          Value: AIPromptGenerator

  # -----------------------------------------
  # IAM Role for Lambda Functions
  # -----------------------------------------
  LambdaExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub 'ai-prompt-generator-lambda-${Environment}'
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
        - arn:aws:iam::aws:policy/AWSXRayDaemonWriteAccess
      Policies:
        - PolicyName: SecretsManagerAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - secretsmanager:GetSecretValue
                Resource: !Ref APIKeysSecret
        - PolicyName: DynamoDBAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - dynamodb:GetItem
                  - dynamodb:PutItem
                  - dynamodb:UpdateItem
                  - dynamodb:Query
                  - dynamodb:DeleteItem
                Resource:
                  - !GetAtt UsageTable.Arn
                  - !Sub '${UsageTable.Arn}/index/*'
                  - !GetAtt RateLimitTable.Arn
      Tags:
        - Key: Environment
          Value: !Ref Environment
        - Key: Project
          Value: AIPromptGenerator

  # -----------------------------------------
  # Lambda Function - Generate Prompt
  # -----------------------------------------
  GeneratePromptFunction:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName: !Sub 'ai-prompt-generator-generate-${Environment}'
      Description: Generate enhanced prompts using AI
      Handler: index.handler
      Role: !GetAtt LambdaExecutionRole.Arn
      Environment:
        Variables:
          SECRETS_ARN: !Ref APIKeysSecret
          USAGE_TABLE: !Ref UsageTable
          RATE_LIMIT_TABLE: !Ref RateLimitTable
          RATE_LIMIT_REQUESTS: !Ref RateLimitRequests
      InlineCode: |
        const { SecretsManagerClient, GetSecretValueCommand } = require('@aws-sdk/client-secrets-manager');
        const { DynamoDBClient } = require('@aws-sdk/client-dynamodb');
        const { DynamoDBDocumentClient, GetCommand, PutCommand, UpdateCommand } = require('@aws-sdk/lib-dynamodb');

        const secretsClient = new SecretsManagerClient();
        const ddbClient = DynamoDBDocumentClient.from(new DynamoDBClient());

        let cachedSecrets = null;

        async function getSecrets() {
          if (cachedSecrets) return cachedSecrets;
          
          const command = new GetSecretValueCommand({ SecretId: process.env.SECRETS_ARN });
          const response = await secretsClient.send(command);
          cachedSecrets = JSON.parse(response.SecretString);
          return cachedSecrets;
        }

        async function checkRateLimit(ip) {
          const now = Math.floor(Date.now() / 1000);
          const windowStart = now - 60;
          
          try {
            const result = await ddbClient.send(new GetCommand({
              TableName: process.env.RATE_LIMIT_TABLE,
              Key: { ip }
            }));
            
            if (result.Item && result.Item.count >= parseInt(process.env.RATE_LIMIT_REQUESTS)) {
              if (result.Item.windowStart > windowStart) {
                return false;
              }
            }
            
            await ddbClient.send(new PutCommand({
              TableName: process.env.RATE_LIMIT_TABLE,
              Item: {
                ip,
                count: (result.Item?.windowStart > windowStart ? result.Item.count : 0) + 1,
                windowStart: result.Item?.windowStart > windowStart ? result.Item.windowStart : now,
                ttl: now + 120
              }
            }));
            
            return true;
          } catch (error) {
            console.error('Rate limit check error:', error);
            return true;
          }
        }

        async function trackUsage(data) {
          const now = new Date();
          const dateStr = now.toISOString().split('T')[0];
          
          await ddbClient.send(new PutCommand({
            TableName: process.env.USAGE_TABLE,
            Item: {
              pk: `USAGE#${dateStr}`,
              sk: `${now.toISOString()}#${Math.random().toString(36).substr(2, 9)}`,
              gsi1pk: 'USAGE',
              gsi1sk: now.toISOString(),
              ...data,
              ttl: Math.floor(Date.now() / 1000) + (90 * 24 * 60 * 60)
            }
          }));
        }

        async function callClaudeAPI(prompt, systemPrompt, apiKey) {
          const response = await fetch('https://api.anthropic.com/v1/messages', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'x-api-key': apiKey,
              'anthropic-version': '2023-06-01'
            },
            body: JSON.stringify({
              model: 'claude-3-haiku-20240307',
              max_tokens: 2048,
              system: systemPrompt,
              messages: [{ role: 'user', content: prompt }]
            })
          });
          
          if (!response.ok) {
            throw new Error(`Claude API error: ${response.status}`);
          }
          
          const data = await response.json();
          return data.content[0].text;
        }

        async function callOpenAIAPI(prompt, systemPrompt, apiKey) {
          const response = await fetch('https://api.openai.com/v1/chat/completions', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${apiKey}`
            },
            body: JSON.stringify({
              model: 'gpt-3.5-turbo',
              max_tokens: 2048,
              messages: [
                { role: 'system', content: systemPrompt },
                { role: 'user', content: prompt }
              ]
            })
          });
          
          if (!response.ok) {
            throw new Error(`OpenAI API error: ${response.status}`);
          }
          
          const data = await response.json();
          return data.choices[0].message.content;
        }

        function buildSystemPrompt(options = {}) {
          const { tone = 'professional', length = 'balanced', model = 'all' } = options;
          
          return `You are an expert prompt engineer. Enhance the user's prompt to get better AI results.
        Add clarity, specificity, context, and structure. ${tone} tone. ${length} length.
        Return ONLY the enhanced prompt without explanations.`;
        }

        exports.handler = async (event) => {
          const headers = {
            'Content-Type': 'application/json',
            'Access-Control-Allow-Origin': '*',
            'Access-Control-Allow-Headers': 'Content-Type',
            'Access-Control-Allow-Methods': 'POST, OPTIONS'
          };
          
          if (event.httpMethod === 'OPTIONS') {
            return { statusCode: 200, headers, body: '' };
          }
          
          try {
            const ip = event.requestContext?.identity?.sourceIp || 'unknown';
            
            if (!await checkRateLimit(ip)) {
              return {
                statusCode: 429,
                headers,
                body: JSON.stringify({ error: 'Rate limit exceeded. Please try again later.' })
              };
            }
            
            const body = JSON.parse(event.body || '{}');
            const { prompt, options = {} } = body;
            
            if (!prompt || typeof prompt !== 'string' || prompt.trim().length === 0) {
              return {
                statusCode: 400,
                headers,
                body: JSON.stringify({ error: 'Prompt is required' })
              };
            }
            
            if (prompt.length > 10000) {
              return {
                statusCode: 400,
                headers,
                body: JSON.stringify({ error: 'Prompt exceeds maximum length of 10000 characters' })
              };
            }
            
            const secrets = await getSecrets();
            const systemPrompt = buildSystemPrompt(options);
            const provider = process.env.AI_PROVIDER;
            
            let enhancedPrompt;
            const startTime = Date.now();
            
            if (provider === 'claude') {
              enhancedPrompt = await callClaudeAPI(
                `Please enhance this prompt:\n\n${prompt}`,
                systemPrompt,
                secrets.CLAUDE_API_KEY
              );
            } else {
              enhancedPrompt = await callOpenAIAPI(
                `Please enhance this prompt:\n\n${prompt}`,
                systemPrompt,
                secrets.OPENAI_API_KEY
              );
            }
            
            const duration = Date.now() - startTime;
            
            await trackUsage({
              inputLength: prompt.length,
              outputLength: enhancedPrompt.length,
              provider,
              duration,
              tone: options.tone,
              model: options.model
            });
            
            return {
              statusCode: 200,
              headers,
              body: JSON.stringify({
                enhancedPrompt,
                metadata: {
                  provider,
                  duration,
                  inputLength: prompt.length,
                  outputLength: enhancedPrompt.length
                }
              })
            };
            
          } catch (error) {
            console.error('Error:', error);
            
            return {
              statusCode: 500,
              headers,
              body: JSON.stringify({
                error: 'An error occurred while generating the prompt',
                message: process.env.ENVIRONMENT !== 'production' ? error.message : undefined
              })
            };
          }
        };
      Events:
        ApiEvent:
          Type: Api
          Properties:
            RestApiId: !Ref APIGateway
            Path: /generate-prompt
            Method: POST

  # -----------------------------------------
  # Lambda Function - Get Analytics
  # -----------------------------------------
  GetAnalyticsFunction:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName: !Sub 'ai-prompt-generator-analytics-${Environment}'
      Description: Get usage analytics
      Handler: index.handler
      Role: !GetAtt LambdaExecutionRole.Arn
      Environment:
        Variables:
          USAGE_TABLE: !Ref UsageTable
      InlineCode: |
        const { DynamoDBClient } = require('@aws-sdk/client-dynamodb');
        const { DynamoDBDocumentClient, QueryCommand } = require('@aws-sdk/lib-dynamodb');

        const ddbClient = DynamoDBDocumentClient.from(new DynamoDBClient());

        exports.handler = async (event) => {
          const headers = {
            'Content-Type': 'application/json',
            'Access-Control-Allow-Origin': '*',
            'Access-Control-Allow-Headers': 'Content-Type',
            'Access-Control-Allow-Methods': 'GET, OPTIONS'
          };
          
          if (event.httpMethod === 'OPTIONS') {
            return { statusCode: 200, headers, body: '' };
          }
          
          try {
            const days = parseInt(event.queryStringParameters?.days || '7');
            const now = new Date();
            const startDate = new Date(now.getTime() - (days * 24 * 60 * 60 * 1000));
            
            const result = await ddbClient.send(new QueryCommand({
              TableName: process.env.USAGE_TABLE,
              IndexName: 'gsi1',
              KeyConditionExpression: 'gsi1pk = :pk AND gsi1sk >= :sk',
              ExpressionAttributeValues: {
                ':pk': 'USAGE',
                ':sk': startDate.toISOString()
              }
            }));
            
            const items = result.Items || [];
            
            const analytics = {
              totalRequests: items.length,
              avgInputLength: items.length > 0 
                ? Math.round(items.reduce((sum, i) => sum + (i.inputLength || 0), 0) / items.length) 
                : 0,
              avgOutputLength: items.length > 0 
                ? Math.round(items.reduce((sum, i) => sum + (i.outputLength || 0), 0) / items.length) 
                : 0,
              avgDuration: items.length > 0 
                ? Math.round(items.reduce((sum, i) => sum + (i.duration || 0), 0) / items.length) 
                : 0,
              byProvider: {},
              byDay: {}
            };
            
            items.forEach(item => {
              const provider = item.provider || 'unknown';
              analytics.byProvider[provider] = (analytics.byProvider[provider] || 0) + 1;
              
              const day = item.gsi1sk?.split('T')[0] || 'unknown';
              analytics.byDay[day] = (analytics.byDay[day] || 0) + 1;
            });
            
            return {
              statusCode: 200,
              headers,
              body: JSON.stringify(analytics)
            };
            
          } catch (error) {
            console.error('Error:', error);
            return {
              statusCode: 500,
              headers,
              body: JSON.stringify({ error: 'Failed to get analytics' })
            };
          }
        };
      Events:
        ApiEvent:
          Type: Api
          Properties:
            RestApiId: !Ref APIGateway
            Path: /analytics
            Method: GET

  # -----------------------------------------
  # API Gateway
  # -----------------------------------------
  APIGateway:
    Type: AWS::Serverless::Api
    Properties:
      Name: !Sub 'ai-prompt-generator-api-${Environment}'
      StageName: !Ref Environment
      Description: AI Prompt Generator API
      EndpointConfiguration:
        Type: REGIONAL
      Cors:
        AllowOrigin: "'*'"
        AllowHeaders: "'Content-Type,Authorization'"
        AllowMethods: "'GET,POST,OPTIONS'"
      MethodSettings:
        - ResourcePath: '/*'
          HttpMethod: '*'
          ThrottlingBurstLimit: 100
          ThrottlingRateLimit: 50
          MetricsEnabled: true
          DataTraceEnabled: !If [IsProduction, false, true]
          LoggingLevel: !If [IsProduction, 'ERROR', 'INFO']
      AccessLogSetting:
        DestinationArn: !GetAtt APIGatewayLogGroup.Arn
        Format: '{"requestId":"$context.requestId","ip":"$context.identity.sourceIp","requestTime":"$context.requestTime","httpMethod":"$context.httpMethod","path":"$context.path","status":"$context.status","responseLength":"$context.responseLength","latency":"$context.responseLatency"}'
      Tags:
        Environment: !Ref Environment
        Project: AIPromptGenerator

  APIGatewayLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub '/aws/apigateway/ai-prompt-generator-${Environment}'
      RetentionInDays: !Ref LogRetentionDays

  # -----------------------------------------
  # CloudWatch Alarms
  # -----------------------------------------
  LambdaErrorAlarm:
    Type: AWS::CloudWatch::Alarm
    Condition: IsProduction
    Properties:
      AlarmName: !Sub 'AIPromptGenerator-LambdaErrors-${Environment}'
      AlarmDescription: Alert when Lambda errors exceed threshold
      MetricName: Errors
      Namespace: AWS/Lambda
      Dimensions:
        - Name: FunctionName
          Value: !Ref GeneratePromptFunction
      Statistic: Sum
      Period: 300
      EvaluationPeriods: 2
      Threshold: 10
      ComparisonOperator: GreaterThanThreshold

  APIGateway4xxAlarm:
    Type: AWS::CloudWatch::Alarm
    Condition: IsProduction
    Properties:
      AlarmName: !Sub 'AIPromptGenerator-API4xx-${Environment}'
      AlarmDescription: Alert when 4xx errors exceed threshold
      MetricName: 4XXError
      Namespace: AWS/ApiGateway
      Dimensions:
        - Name: ApiName
          Value: !Sub 'ai-prompt-generator-api-${Environment}'
        - Name: Stage
          Value: !Ref Environment
      Statistic: Sum
      Period: 300
      EvaluationPeriods: 2
      Threshold: 100
      ComparisonOperator: GreaterThanThreshold

# =========================================
# Outputs
# =========================================
Outputs:
  APIEndpoint:
    Description: API Gateway endpoint URL
    Value: !Sub 'https://${APIGateway}.execute-api.${AWS::Region}.amazonaws.com/${Environment}'
    Export:
      Name: !Sub '${AWS::StackName}-APIEndpoint'

  GeneratePromptFunctionArn:
    Description: ARN of the Generate Prompt Lambda function
    Value: !GetAtt GeneratePromptFunction.Arn
    Export:
      Name: !Sub '${AWS::StackName}-GeneratePromptFunctionArn'

  UsageTableName:
    Description: Name of the DynamoDB usage table
    Value: !Ref UsageTable
    Export:
      Name: !Sub '${AWS::StackName}-UsageTable'

  APIKeysSecretArn:
    Description: ARN of the Secrets Manager secret for API keys
    Value: !Ref APIKeysSecret
    Export:
      Name: !Sub '${AWS::StackName}-APIKeysSecret'
